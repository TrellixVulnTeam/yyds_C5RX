{"ast":null,"code":"import { Observable, of, from } from 'rxjs';\nimport { debounceTime, map, switchMap } from 'rxjs/operators';\nimport * as i1 from '@angular/fire';\nimport { observeOutsideAngular, keepUnstableUntilFirst, ɵcacheInstance, VERSION } from '@angular/fire';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, Pipe, NgModule } from '@angular/core';\nimport { ɵfirebaseAppFactory, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire/compat';\nimport 'firebase/compat/storage';\nimport { AsyncPipe } from '@angular/common';\nimport firebase from 'firebase/compat/app'; // Things aren't working great, I'm having to put in a lot of work-arounds for what\n// appear to be Firebase JS SDK bugs https://github.com/firebase/firebase-js-sdk/issues/4158\n\nfunction fromTask(task) {\n  return new Observable(subscriber => {\n    const progress = snap => subscriber.next(snap);\n\n    const error = e => subscriber.error(e);\n\n    const complete = () => subscriber.complete(); // emit the current snapshot, so they don't have to wait for state_changes\n    // to fire next... this is stale if the task is no longer running :(\n\n\n    progress(task.snapshot);\n    const unsub = task.on('state_changed', progress); // it turns out that neither task snapshot nor 'state_changed' fire the last\n    // snapshot before completion, the one with status 'success\" and 100% progress\n    // so let's use the promise form of the task for that\n\n    task.then(snapshot => {\n      progress(snapshot);\n      complete();\n    }, e => {\n      // TODO investigate, again this is stale, we never fire a canceled or error it seems\n      progress(task.snapshot);\n      error(e);\n    }); // on's type if Function, rather than () => void, need to wrap\n\n    return function unsubscribe() {\n      unsub();\n    };\n  }).pipe( // deal with sync emissions from first emitting `task.snapshot`, this makes sure\n  // that if the task is already finished we don't emit the old running state\n  debounceTime(0));\n}\n/**\n * Create an AngularFireUploadTask from a regular UploadTask from the Storage SDK.\n * This method creates an observable of the upload and returns on object that provides\n * multiple methods for controlling and monitoring the file upload.\n */\n\n\nfunction createUploadTask(task) {\n  const inner$ = fromTask(task);\n  return {\n    task,\n    then: task.then.bind(task),\n    catch: task.catch.bind(task),\n    pause: task.pause.bind(task),\n    cancel: task.cancel.bind(task),\n    resume: task.resume.bind(task),\n    snapshotChanges: () => inner$,\n    percentageChanges: () => inner$.pipe(map(s => s.bytesTransferred / s.totalBytes * 100))\n  };\n}\n/**\n * Create an AngularFire wrapped Storage Reference. This object\n * creates observable methods from promise based methods.\n */\n\n\nfunction createStorageRef(ref) {\n  return {\n    getDownloadURL: () => of(undefined).pipe(observeOutsideAngular, switchMap(() => ref.getDownloadURL()), keepUnstableUntilFirst),\n    getMetadata: () => of(undefined).pipe(observeOutsideAngular, switchMap(() => ref.getMetadata()), keepUnstableUntilFirst),\n    delete: () => from(ref.delete()),\n    child: path => createStorageRef(ref.child(path)),\n    updateMetadata: meta => from(ref.updateMetadata(meta)),\n    put: (data, metadata) => {\n      const task = ref.put(data, metadata);\n      return createUploadTask(task);\n    },\n    putString: (data, format, metadata) => {\n      const task = ref.putString(data, format, metadata);\n      return createUploadTask(task);\n    },\n    listAll: () => from(ref.listAll())\n  };\n}\n\nconst BUCKET = new InjectionToken('angularfire2.storageBucket');\nconst MAX_UPLOAD_RETRY_TIME = new InjectionToken('angularfire2.storage.maxUploadRetryTime');\nconst MAX_OPERATION_RETRY_TIME = new InjectionToken('angularfire2.storage.maxOperationRetryTime');\nconst USE_EMULATOR = new InjectionToken('angularfire2.storage.use-emulator');\n/**\n * AngularFireStorage Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for uploading and downloading binary files from Cloud Storage for\n * Firebase.\n */\n\nclass AngularFireStorage {\n  constructor(options, name, storageBucket, // tslint:disable-next-line:ban-types\n  platformId, zone, schedulers, maxUploadRetryTime, maxOperationRetryTime, _useEmulator) {\n    const app = ɵfirebaseAppFactory(options, zone, name);\n    this.storage = ɵcacheInstance(`${app.name}.storage.${storageBucket}`, 'AngularFireStorage', app.name, () => {\n      const storage = zone.runOutsideAngular(() => app.storage(storageBucket || undefined));\n      const useEmulator = _useEmulator;\n\n      if (useEmulator) {\n        storage.useEmulator(...useEmulator);\n      }\n\n      if (maxUploadRetryTime) {\n        storage.setMaxUploadRetryTime(maxUploadRetryTime);\n      }\n\n      if (maxOperationRetryTime) {\n        storage.setMaxOperationRetryTime(maxOperationRetryTime);\n      }\n\n      return storage;\n    }, [maxUploadRetryTime, maxOperationRetryTime]);\n  }\n\n  ref(path) {\n    return createStorageRef(this.storage.ref(path));\n  }\n\n  refFromURL(path) {\n    return createStorageRef(this.storage.refFromURL(path));\n  }\n\n  upload(path, data, metadata) {\n    const storageRef = this.storage.ref(path);\n    const ref = createStorageRef(storageRef);\n    return ref.put(data, metadata);\n  }\n\n}\n\nAngularFireStorage.ɵfac = function AngularFireStorage_Factory(t) {\n  return new (t || AngularFireStorage)(i0.ɵɵinject(FIREBASE_OPTIONS), i0.ɵɵinject(FIREBASE_APP_NAME, 8), i0.ɵɵinject(BUCKET, 8), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.ɵAngularFireSchedulers), i0.ɵɵinject(MAX_UPLOAD_RETRY_TIME, 8), i0.ɵɵinject(MAX_OPERATION_RETRY_TIME, 8), i0.ɵɵinject(USE_EMULATOR, 8));\n};\n\nAngularFireStorage.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AngularFireStorage,\n  factory: AngularFireStorage.ɵfac,\n  providedIn: 'any'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AngularFireStorage, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'any'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [FIREBASE_OPTIONS]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [FIREBASE_APP_NAME]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [BUCKET]\n      }]\n    }, {\n      type: Object,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i1.ɵAngularFireSchedulers\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [MAX_UPLOAD_RETRY_TIME]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [MAX_OPERATION_RETRY_TIME]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [USE_EMULATOR]\n      }]\n    }];\n  }, null);\n})();\n/** to be used with in combination with | async */\n\n\nclass GetDownloadURLPipe {\n  constructor(storage, cdr) {\n    this.storage = storage;\n    this.asyncPipe = new AsyncPipe(cdr);\n  }\n\n  transform(path) {\n    if (path !== this.path) {\n      this.path = path;\n      this.downloadUrl$ = this.storage.ref(path).getDownloadURL();\n    }\n\n    return this.asyncPipe.transform(this.downloadUrl$);\n  }\n\n  ngOnDestroy() {\n    this.asyncPipe.ngOnDestroy();\n  }\n\n}\n\nGetDownloadURLPipe.ɵfac = function GetDownloadURLPipe_Factory(t) {\n  return new (t || GetDownloadURLPipe)(i0.ɵɵdirectiveInject(AngularFireStorage, 16), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef, 16));\n};\n\nGetDownloadURLPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n  name: \"getDownloadURL\",\n  type: GetDownloadURLPipe,\n  pure: false\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(GetDownloadURLPipe, [{\n    type: Pipe,\n    args: [{\n      name: 'getDownloadURL',\n      pure: false\n    }]\n  }], function () {\n    return [{\n      type: AngularFireStorage\n    }, {\n      type: i0.ChangeDetectorRef\n    }];\n  }, null);\n})();\n\nclass GetDownloadURLPipeModule {}\n\nGetDownloadURLPipeModule.ɵfac = function GetDownloadURLPipeModule_Factory(t) {\n  return new (t || GetDownloadURLPipeModule)();\n};\n\nGetDownloadURLPipeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: GetDownloadURLPipeModule,\n  declarations: [GetDownloadURLPipe],\n  exports: [GetDownloadURLPipe]\n});\nGetDownloadURLPipeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(GetDownloadURLPipeModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [GetDownloadURLPipe],\n      exports: [GetDownloadURLPipe]\n    }]\n  }], null, null);\n})();\n\nclass AngularFireStorageModule {\n  constructor() {\n    firebase.registerVersion('angularfire', VERSION.full, 'gcs-compat');\n  }\n\n}\n\nAngularFireStorageModule.ɵfac = function AngularFireStorageModule_Factory(t) {\n  return new (t || AngularFireStorageModule)();\n};\n\nAngularFireStorageModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: AngularFireStorageModule,\n  exports: [GetDownloadURLPipeModule]\n});\nAngularFireStorageModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [AngularFireStorage],\n  imports: [GetDownloadURLPipeModule]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AngularFireStorageModule, [{\n    type: NgModule,\n    args: [{\n      exports: [GetDownloadURLPipeModule],\n      providers: [AngularFireStorage]\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AngularFireStorage, AngularFireStorageModule, BUCKET, GetDownloadURLPipe, GetDownloadURLPipeModule, MAX_OPERATION_RETRY_TIME, MAX_UPLOAD_RETRY_TIME, USE_EMULATOR, createStorageRef, createUploadTask, fromTask }; //# sourceMappingURL=angular-fire-compat-storage.js.map","map":{"version":3,"sources":["/Users/zhaochenxu/Desktop/yyds/node_modules/@angular/fire/fesm2015/angular-fire-compat-storage.js"],"names":["Observable","of","from","debounceTime","map","switchMap","i1","observeOutsideAngular","keepUnstableUntilFirst","ɵcacheInstance","VERSION","i0","InjectionToken","PLATFORM_ID","Injectable","Inject","Optional","Pipe","NgModule","ɵfirebaseAppFactory","FIREBASE_OPTIONS","FIREBASE_APP_NAME","AsyncPipe","firebase","fromTask","task","subscriber","progress","snap","next","error","e","complete","snapshot","unsub","on","then","unsubscribe","pipe","createUploadTask","inner$","bind","catch","pause","cancel","resume","snapshotChanges","percentageChanges","s","bytesTransferred","totalBytes","createStorageRef","ref","getDownloadURL","undefined","getMetadata","delete","child","path","updateMetadata","meta","put","data","metadata","putString","format","listAll","BUCKET","MAX_UPLOAD_RETRY_TIME","MAX_OPERATION_RETRY_TIME","USE_EMULATOR","AngularFireStorage","constructor","options","name","storageBucket","platformId","zone","schedulers","maxUploadRetryTime","maxOperationRetryTime","_useEmulator","app","storage","runOutsideAngular","useEmulator","setMaxUploadRetryTime","setMaxOperationRetryTime","refFromURL","upload","storageRef","ɵfac","NgZone","ɵAngularFireSchedulers","ɵprov","type","args","providedIn","decorators","Object","GetDownloadURLPipe","cdr","asyncPipe","transform","downloadUrl$","ngOnDestroy","ChangeDetectorRef","ɵpipe","pure","GetDownloadURLPipeModule","ɵmod","ɵinj","declarations","exports","AngularFireStorageModule","registerVersion","full","providers"],"mappings":"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","sourcesContent":["import { Observable, of, from } from 'rxjs';\nimport { debounceTime, map, switchMap } from 'rxjs/operators';\nimport * as i1 from '@angular/fire';\nimport { observeOutsideAngular, keepUnstableUntilFirst, ɵcacheInstance, VERSION } from '@angular/fire';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, Pipe, NgModule } from '@angular/core';\nimport { ɵfirebaseAppFactory, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire/compat';\nimport 'firebase/compat/storage';\nimport { AsyncPipe } from '@angular/common';\nimport firebase from 'firebase/compat/app';\n\n// Things aren't working great, I'm having to put in a lot of work-arounds for what\n// appear to be Firebase JS SDK bugs https://github.com/firebase/firebase-js-sdk/issues/4158\nfunction fromTask(task) {\n    return new Observable(subscriber => {\n        const progress = (snap) => subscriber.next(snap);\n        const error = e => subscriber.error(e);\n        const complete = () => subscriber.complete();\n        // emit the current snapshot, so they don't have to wait for state_changes\n        // to fire next... this is stale if the task is no longer running :(\n        progress(task.snapshot);\n        const unsub = task.on('state_changed', progress);\n        // it turns out that neither task snapshot nor 'state_changed' fire the last\n        // snapshot before completion, the one with status 'success\" and 100% progress\n        // so let's use the promise form of the task for that\n        task.then(snapshot => {\n            progress(snapshot);\n            complete();\n        }, e => {\n            // TODO investigate, again this is stale, we never fire a canceled or error it seems\n            progress(task.snapshot);\n            error(e);\n        });\n        // on's type if Function, rather than () => void, need to wrap\n        return function unsubscribe() {\n            unsub();\n        };\n    }).pipe(\n    // deal with sync emissions from first emitting `task.snapshot`, this makes sure\n    // that if the task is already finished we don't emit the old running state\n    debounceTime(0));\n}\n\n/**\n * Create an AngularFireUploadTask from a regular UploadTask from the Storage SDK.\n * This method creates an observable of the upload and returns on object that provides\n * multiple methods for controlling and monitoring the file upload.\n */\nfunction createUploadTask(task) {\n    const inner$ = fromTask(task);\n    return {\n        task,\n        then: task.then.bind(task),\n        catch: task.catch.bind(task),\n        pause: task.pause.bind(task),\n        cancel: task.cancel.bind(task),\n        resume: task.resume.bind(task),\n        snapshotChanges: () => inner$,\n        percentageChanges: () => inner$.pipe(map(s => s.bytesTransferred / s.totalBytes * 100))\n    };\n}\n\n/**\n * Create an AngularFire wrapped Storage Reference. This object\n * creates observable methods from promise based methods.\n */\nfunction createStorageRef(ref) {\n    return {\n        getDownloadURL: () => of(undefined).pipe(observeOutsideAngular, switchMap(() => ref.getDownloadURL()), keepUnstableUntilFirst),\n        getMetadata: () => of(undefined).pipe(observeOutsideAngular, switchMap(() => ref.getMetadata()), keepUnstableUntilFirst),\n        delete: () => from(ref.delete()),\n        child: (path) => createStorageRef(ref.child(path)),\n        updateMetadata: (meta) => from(ref.updateMetadata(meta)),\n        put: (data, metadata) => {\n            const task = ref.put(data, metadata);\n            return createUploadTask(task);\n        },\n        putString: (data, format, metadata) => {\n            const task = ref.putString(data, format, metadata);\n            return createUploadTask(task);\n        },\n        listAll: () => from(ref.listAll())\n    };\n}\n\nconst BUCKET = new InjectionToken('angularfire2.storageBucket');\nconst MAX_UPLOAD_RETRY_TIME = new InjectionToken('angularfire2.storage.maxUploadRetryTime');\nconst MAX_OPERATION_RETRY_TIME = new InjectionToken('angularfire2.storage.maxOperationRetryTime');\nconst USE_EMULATOR = new InjectionToken('angularfire2.storage.use-emulator');\n/**\n * AngularFireStorage Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for uploading and downloading binary files from Cloud Storage for\n * Firebase.\n */\nclass AngularFireStorage {\n    constructor(options, name, storageBucket, \n    // tslint:disable-next-line:ban-types\n    platformId, zone, schedulers, maxUploadRetryTime, maxOperationRetryTime, _useEmulator) {\n        const app = ɵfirebaseAppFactory(options, zone, name);\n        this.storage = ɵcacheInstance(`${app.name}.storage.${storageBucket}`, 'AngularFireStorage', app.name, () => {\n            const storage = zone.runOutsideAngular(() => app.storage(storageBucket || undefined));\n            const useEmulator = _useEmulator;\n            if (useEmulator) {\n                storage.useEmulator(...useEmulator);\n            }\n            if (maxUploadRetryTime) {\n                storage.setMaxUploadRetryTime(maxUploadRetryTime);\n            }\n            if (maxOperationRetryTime) {\n                storage.setMaxOperationRetryTime(maxOperationRetryTime);\n            }\n            return storage;\n        }, [maxUploadRetryTime, maxOperationRetryTime]);\n    }\n    ref(path) {\n        return createStorageRef(this.storage.ref(path));\n    }\n    refFromURL(path) {\n        return createStorageRef(this.storage.refFromURL(path));\n    }\n    upload(path, data, metadata) {\n        const storageRef = this.storage.ref(path);\n        const ref = createStorageRef(storageRef);\n        return ref.put(data, metadata);\n    }\n}\nAngularFireStorage.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: AngularFireStorage, deps: [{ token: FIREBASE_OPTIONS }, { token: FIREBASE_APP_NAME, optional: true }, { token: BUCKET, optional: true }, { token: PLATFORM_ID }, { token: i0.NgZone }, { token: i1.ɵAngularFireSchedulers }, { token: MAX_UPLOAD_RETRY_TIME, optional: true }, { token: MAX_OPERATION_RETRY_TIME, optional: true }, { token: USE_EMULATOR, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\nAngularFireStorage.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: AngularFireStorage, providedIn: 'any' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: AngularFireStorage, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'any'\n                }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [FIREBASE_OPTIONS]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [FIREBASE_APP_NAME]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [BUCKET]\n                }] }, { type: Object, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }, { type: i0.NgZone }, { type: i1.ɵAngularFireSchedulers }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [MAX_UPLOAD_RETRY_TIME]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [MAX_OPERATION_RETRY_TIME]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [USE_EMULATOR]\n                }] }]; } });\n\n/** to be used with in combination with | async */\nclass GetDownloadURLPipe {\n    constructor(storage, cdr) {\n        this.storage = storage;\n        this.asyncPipe = new AsyncPipe(cdr);\n    }\n    transform(path) {\n        if (path !== this.path) {\n            this.path = path;\n            this.downloadUrl$ = this.storage.ref(path).getDownloadURL();\n        }\n        return this.asyncPipe.transform(this.downloadUrl$);\n    }\n    ngOnDestroy() {\n        this.asyncPipe.ngOnDestroy();\n    }\n}\nGetDownloadURLPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: GetDownloadURLPipe, deps: [{ token: AngularFireStorage }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Pipe });\nGetDownloadURLPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: GetDownloadURLPipe, name: \"getDownloadURL\", pure: false });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: GetDownloadURLPipe, decorators: [{\n            type: Pipe,\n            args: [{\n                    name: 'getDownloadURL',\n                    pure: false,\n                }]\n        }], ctorParameters: function () { return [{ type: AngularFireStorage }, { type: i0.ChangeDetectorRef }]; } });\nclass GetDownloadURLPipeModule {\n}\nGetDownloadURLPipeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: GetDownloadURLPipeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nGetDownloadURLPipeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: GetDownloadURLPipeModule, declarations: [GetDownloadURLPipe], exports: [GetDownloadURLPipe] });\nGetDownloadURLPipeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: GetDownloadURLPipeModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: GetDownloadURLPipeModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [GetDownloadURLPipe],\n                    exports: [GetDownloadURLPipe],\n                }]\n        }] });\n\nclass AngularFireStorageModule {\n    constructor() {\n        firebase.registerVersion('angularfire', VERSION.full, 'gcs-compat');\n    }\n}\nAngularFireStorageModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: AngularFireStorageModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nAngularFireStorageModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: AngularFireStorageModule, exports: [GetDownloadURLPipeModule] });\nAngularFireStorageModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: AngularFireStorageModule, providers: [AngularFireStorage], imports: [GetDownloadURLPipeModule] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: AngularFireStorageModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    exports: [GetDownloadURLPipeModule],\n                    providers: [AngularFireStorage]\n                }]\n        }], ctorParameters: function () { return []; } });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularFireStorage, AngularFireStorageModule, BUCKET, GetDownloadURLPipe, GetDownloadURLPipeModule, MAX_OPERATION_RETRY_TIME, MAX_UPLOAD_RETRY_TIME, USE_EMULATOR, createStorageRef, createUploadTask, fromTask };\n//# sourceMappingURL=angular-fire-compat-storage.js.map\n"]},"metadata":{},"sourceType":"module"}